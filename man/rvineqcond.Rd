% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Rvine-Rosenblatt-v2.R
\name{rvineqcond}
\alias{rvineqcond}
\title{Rosenblatt transform (forward)}
\usage{
rvineqcond(
  p,
  A,
  fam,
  param1,
  param2,
  ntrunc = 0,
  varname = numeric(0),
  iprint = FALSE
)
}
\arguments{
\item{p}{vector of length d with values in interval (0,1)}

\item{A}{dxd vine array with 1:d on diagonal, d>=2
if truncated vine, only rows 1 to ntrunc are used.}

\item{fam}{dxd code matrix (VineCopula copula family index) .}

\item{param1}{dxd parameter matrix (VineCopula first copula parameter)
param1[l,j] for tree l, variable j.}

\item{param2}{dxd parameter matrix (VineCopula second copula parameter)
param2[l,j] for tree l, variable j; 0 if not needed.}

\item{ntrunc}{truncation level, integer between 1 and d-1 (d-1 for no truncation)}

\item{varname}{character vector of variable names, optional}

\item{iprint}{print flag for intermediate calculations}
}
\value{
d-vector of values in (0,1)
  If p is vector of independent U(0,1), then output is a random vector from the vine copula
    based on A, fam, param1, param2, ntrunc
that is, u1=p1, C_{2|1}^{-1}(p2|u1), C_{3|12}^{-1}(p3|u1,u2), ...  C_{d|1..d-1}^{-1}(p_d|u[1:(d-1)])
}
\description{
Rosenblatt transform (forward) for R-vine based on diagonal order in vine array
 This is R-vine simulation if p is a vector of independent U(0,1)
 Algorithms 17 and 18 in Joe (2014).
 This function could be vectorized for simulations (random sample size n).
}
\details{
BiCopHinv1 is from VineCopula for inverse of conditional cdf C_{2|1}^{-1}(v|u)
BiCopHfunc2 is from VineCopula for conditional cdf C_{1|2}(u|v)
}
\examples{
# example code

}
